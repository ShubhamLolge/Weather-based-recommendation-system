// // // // main.dart
import 'dart:async';
import 'dart:html' as html;
import 'package:csv/csv.dart';
import 'package:flutter/material.dart';
import 'package:weather_app/models/weather_data.dart';
import 'package:weather_app/services/services.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Inventory Preview',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: const SalesPredictionPage(),
    );
  }
}

class SalesPredictionPage extends StatefulWidget {
  const SalesPredictionPage({super.key});

  @override
  SalesPredictionPageState createState() => SalesPredictionPageState();
}

class SalesPredictionPageState extends State<SalesPredictionPage> {
  final TextEditingController _storeNameController = TextEditingController(text: "The Mount Stuart - JD Wetherspoon");
  final TextEditingController _storeLocationController = TextEditingController(text: "Cardiff");
  final Services services = Services();

  List<List<dynamic>> _csvData = [];
  List<Map<String, dynamic>> _predictions = []; // Change this to a list of maps

  String csv = "";

  WeatherData? weatherData;

  bool _isLoadingCsv = false;
  bool _isLoadingWeather = false;
  bool _isLoadingPrediction = false;

  void _loadCsvData() async {
    setState(() {
      _isLoadingCsv = true;
    });

    final inventoryPreview = InventoryPreview();
    final data = await inventoryPreview.loadCsvFile();
    final csvData = const ListToCsvConverter().convert(data);
    setState(() {
      _csvData = data;
      csv = csvData;
      _isLoadingCsv = false;
    });
  }

  Future<void> _fetchWeatherData() async {
    final location = _storeLocationController.text;
    if (location.isNotEmpty) {
      setState(() {
        _isLoadingWeather = true;
      });

      try {
        WeatherData wd = await services.fetchWeather(
          context: context,
          location: location,
        );

        setState(() {
          weatherData = wd;
          _isLoadingWeather = false;
        });
      } catch (e) {
        debugPrint(e.toString());
        setState(() {
          _predictions = [
            {'Error': 'Could not fetch weather data.'}
          ];
          _isLoadingWeather = false;
        });
      }
    } else {
      setState(() {
        _predictions = [
          {'Error': 'Please enter a location'}
        ];
      });
    }
  }

  Future<void> _sendDataAndPredict() async {
    if (_csvData.isEmpty) {
      setState(() {
        _predictions = [
          {'Error': 'Please upload inventory data first.'}
        ];
      });
      return;
    }

    final storeName = _storeNameController.text;
    final storeLocation = _storeLocationController.text;

    if (weatherData == null) {
      setState(() {
        _predictions = [
          {'Error': 'Please fetch weather data first.'}
        ];
      });
      return;
    }

    final csvData = const ListToCsvConverter().convert(_csvData);

    setState(() {
      _isLoadingPrediction = true;
    });

    try {
      final data = await services.uploadAndPredict(
        context: context,
        weatherData: weatherData!, // nullable
        storeName: storeName,
        storeLocation: storeLocation,
        csvData: csvData,
      );

      setState(() {
        if (data.containsKey('predicted_sales')) {
          _predictions = List<Map<String, dynamic>>.from(data['predicted_sales']);
        } else {
          _predictions = [
            {'Error': 'Could not fetch prediction.'}
          ];
        }
        _isLoadingPrediction = false;
      });
    } catch (e) {
      debugPrint('Exception: $e');
      setState(() {
        _predictions = [
          {'Error': 'Could not fetch prediction.'}
        ];
        _isLoadingPrediction = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    Size size = MediaQuery.of(context).size;
    return Scaffold(
      appBar: AppBar(title: const Text('Sales Prediction')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          children: [
            TextField(
              controller: _storeNameController,
              decoration: const InputDecoration(labelText: 'Store Name'),
            ),
            TextField(
              controller: _storeLocationController,
              decoration: const InputDecoration(labelText: 'Store Location'),
            ),
            const SizedBox(height: 20),
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Container(
                  height: size.height * 0.5,
                  width: size.width * 0.3,
                  padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 10),
                  child: SingleChildScrollView(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        ElevatedButton(
                          onPressed: _isLoadingCsv ? null : _loadCsvData,
                          child: _isLoadingCsv ? const CircularProgressIndicator() : const Text('Load Inventory'),
                        ),
                        const SizedBox(height: 10),
                        const Text("Inventory Data", style: TextStyle(fontWeight: FontWeight.bold)),
                        const SizedBox(height: 20),
                        Text(csv.isEmpty ? 'No Data.' : csv),
                      ],
                    ),
                  ),
                ),
                const SizedBox(width: 20),
                Container(
                  height: size.height * 0.5,
                  width: size.width * 0.3,
                  padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 10),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      ElevatedButton(
                        onPressed: _isLoadingWeather ? null : _fetchWeatherData,
                        child: _isLoadingWeather ? const CircularProgressIndicator() : const Text('Fetch weather data'),
                      ),
                      const SizedBox(height: 10),
                      const Text("Weather Data", style: TextStyle(fontWeight: FontWeight.bold)),
                      const SizedBox(height: 20),
                      Text(_storeLocationController.text.isEmpty ? "No location data" : "location: ${_storeLocationController.text}"),
                      const SizedBox(height: 20),
                      weatherData == null
                          ? const Text("No Weather Data")
                          : Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text("temperature: ${weatherData!.temperature}"),
                                Text("rain: ${weatherData!.additionalProperties['rain']}"),
                                Text("wind_speed: ${weatherData!.windSpeed}"),
                                Text("humidity: ${weatherData!.humidity}"),
                                Text("pressure: ${weatherData!.pressure}"),
                                Text("visibility: ${weatherData!.visibility}"),
                                Text("clouds: ${weatherData!.clouds}"),
                                Text("weather: ${weatherData!.weatherMain}"),
                              ],
                            ),
                    ],
                  ),
                ),
                const SizedBox(width: 20),
                Container(
                  height: size.height * 0.5,
                  width: size.width * 0.3,
                  padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 10),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      ElevatedButton(
                        onPressed: _isLoadingPrediction
                            ? null
                            : () {
                                setState(() {
                                  _predictions = [];
                                });
                                _sendDataAndPredict();
                              },
                        child: _isLoadingPrediction ? const CircularProgressIndicator() : const Text('Predict Sales'),
                      ),
                      const SizedBox(height: 10),
                      const Text("Prediction", style: TextStyle(fontWeight: FontWeight.bold)),
                      const SizedBox(height: 20),
                      _predictions.isEmpty
                          ? const Text('Click Predict Sales')
                          : Expanded(
                              child: ListView.builder(
                                itemCount: _predictions.length,
                                itemBuilder: (context, index) {
                                  final prediction = _predictions[index];
                                  return ListTile(
                                    title: Text('Item ID: ${prediction['item_id']}'),
                                    subtitle: Text(
                                      'Current Stock: ${prediction['current_stock']}, Predicted Demand: ${prediction['predicted_demand']}, Restock Quantity: ${prediction['restock_quantity']}',
                                    ),
                                  );
                                },
                              ),
                            ),
                    ],
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

class InventoryPreview {
  Future<List<List<dynamic>>> loadCsvFile() async {
    final completer = Completer<List<List<dynamic>>>();
    final input = html.FileUploadInputElement()..accept = '.csv';
    input.click();

    input.onChange.listen((e) {
      final reader = html.FileReader();
      reader.readAsText(input.files!.first);
      reader.onLoadEnd.listen((e) {
        final csvData = reader.result as String;
        final List<List<dynamic>> data = const CsvToListConverter().convert(csvData);
        completer.complete(data);
      });
    });

    return completer.future;
  }
}



// // // // services.dart
// ignore_for_file: avoid_print

import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:weather_app/models/weather_data.dart';

String apiID = '773211ac46a8a3e591f72ae278de8280';
String flaskAPIuri = 'http://127.0.0.1:5000';
String weatherURI = 'http://api.openweathermap.org';

class Services {
  Future<Map<String, dynamic>> uploadAndPredict({
    required BuildContext context,
    required WeatherData weatherData,
    required String storeName,
    required String storeLocation,
    required String csvData,
  }) async {
    try {
      final data = {
        ...weatherData.toJson(),
        'store_name': storeName,
        'store_location': storeLocation,
        'csv_data': csvData,
      };

      http.Response res = await http.post(
        Uri.parse('$flaskAPIuri/upload'),
        body: jsonEncode(data),
        headers: <String, String>{
          'Content-Type': 'application/json; charset=UTF-8',
        },
      );

      if (res.statusCode == 200) {
        return jsonDecode(res.body);
      } else {
        _httpErrorHandle(response: res, context: context);
        return {};
      }
    } catch (e) {
      print(e.toString());
      _showSnackbar(context: context, text: e.toString());
      return {};
    }
  }

  Future<WeatherData> fetchWeather({
    required BuildContext context,
    required String location,
  }) async {
    try {
      final weatherUrl = '$weatherURI/data/2.5/weather?q=$location&appid=$apiID&units=metric';

      http.Response res = await http.get(Uri.parse(weatherUrl));

      if (res.headers['content-type']?.contains('application/json') == true) {
        final weatherData = json.decode(res.body);
        final WeatherData weather = WeatherData(
          cityName: weatherData['name'],
          country: weatherData['sys']['country'],
          latitude: weatherData['coord']['lat'],
          longitude: weatherData['coord']['lon'],
          population: 0,
          sunrise: weatherData['sys']['sunrise'],
          sunset: weatherData['sys']['sunset'],
          timezone: weatherData['timezone'],
          temperature: weatherData['main']['temp'],
          feelsLike: weatherData['main']['feels_like'],
          humidity: weatherData['main']['humidity'],
          pressure: weatherData['main']['pressure'],
          visibility: weatherData['visibility'],
          windSpeed: weatherData['wind']['speed'],
          clouds: weatherData['clouds']['all'],
          weatherMain: weatherData['weather'][0]['main'],
          weatherDescription: weatherData['weather'][0]['description'],
          additionalProperties: {
            'rain': weatherData['rain']?['1h'] ?? 0,
            'wind_deg': weatherData['wind']['deg'],
            'wind_gust': weatherData['wind']['gust'],
          },
        );

        // print("Weather data: $weather");
        return weather;
      } else {
        throw const FormatException('Invalid JSON response');
      }
    } catch (e) {
      print(e.toString());
      _showSnackbar(context: context, text: e.toString());
      throw e;
    }
  }

  void _httpErrorHandle({
    required http.Response response,
    required BuildContext context,
  }) {
    switch (response.statusCode) {
      case 400:
        _showSnackbar(context: context, text: jsonDecode(response.body)['msg']);
        break;
      case 500:
        _showSnackbar(context: context, text: jsonDecode(response.body)['error']);
        break;
      default:
        _showSnackbar(context: context, text: response.body);
    }
  }

  void _showSnackbar({
    required BuildContext context,
    required String text,
  }) {
    final snackBar = SnackBar(content: Text(text));
    ScaffoldMessenger.of(context).showSnackBar(snackBar);
  }
}



// // // // weather_data.dart
import 'dart:convert';
import 'package:collection/collection.dart';

class WeatherData {
  // City and general information
  final String cityName; // Name of the city
  final String country; // Country code
  final double latitude; // Latitude of the city
  final double longitude; // Longitude of the city
  final int population; // Population of the city
  final int sunrise; // Sunrise time (UNIX timestamp)
  final int sunset; // Sunset time (UNIX timestamp)
  final int timezone; // Timezone offset in seconds

  // Weather information
  final double temperature; // Current temperature
  final double feelsLike; // Feels like temperature
  final int humidity; // Humidity percentage
  final int pressure; // Atmospheric pressure
  final int visibility; // Visibility in meters
  final double windSpeed; // Wind speed in meters/second
  final int clouds; // Cloudiness percentage
  final String weatherMain; // Main weather description (e.g., Rain)
  final String weatherDescription; // Detailed weather description

  // Additional less relevant properties stored in a map
  final Map<String, dynamic> additionalProperties;
  WeatherData({
    required this.cityName,
    required this.country,
    required this.latitude,
    required this.longitude,
    required this.population,
    required this.sunrise,
    required this.sunset,
    required this.timezone,
    required this.temperature,
    required this.feelsLike,
    required this.humidity,
    required this.pressure,
    required this.visibility,
    required this.windSpeed,
    required this.clouds,
    required this.weatherMain,
    required this.weatherDescription,
    required this.additionalProperties,
  });

  WeatherData copyWith({
    String? cityName,
    String? country,
    double? latitude,
    double? longitude,
    int? population,
    int? sunrise,
    int? sunset,
    int? timezone,
    double? temperature,
    double? feelsLike,
    int? humidity,
    int? pressure,
    int? visibility,
    double? windSpeed,
    int? clouds,
    String? weatherMain,
    String? weatherDescription,
    Map<String, dynamic>? additionalProperties,
  }) {
    return WeatherData(
      cityName: cityName ?? this.cityName,
      country: country ?? this.country,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      population: population ?? this.population,
      sunrise: sunrise ?? this.sunrise,
      sunset: sunset ?? this.sunset,
      timezone: timezone ?? this.timezone,
      temperature: temperature ?? this.temperature,
      feelsLike: feelsLike ?? this.feelsLike,
      humidity: humidity ?? this.humidity,
      pressure: pressure ?? this.pressure,
      visibility: visibility ?? this.visibility,
      windSpeed: windSpeed ?? this.windSpeed,
      clouds: clouds ?? this.clouds,
      weatherMain: weatherMain ?? this.weatherMain,
      weatherDescription: weatherDescription ?? this.weatherDescription,
      additionalProperties: additionalProperties ?? this.additionalProperties,
    );
  }

  Map<String, dynamic> toMap() {
    return <String, dynamic>{
      'cityName': cityName,
      'country': country,
      'latitude': latitude,
      'longitude': longitude,
      'population': population,
      'sunrise': sunrise,
      'sunset': sunset,
      'timezone': timezone,
      'temperature': temperature,
      'feelsLike': feelsLike,
      'humidity': humidity,
      'pressure': pressure,
      'visibility': visibility,
      'windSpeed': windSpeed,
      'clouds': clouds,
      'weatherMain': weatherMain,
      'weatherDescription': weatherDescription,
      'additionalProperties': additionalProperties,
    };
  }

  factory WeatherData.fromMap(Map<String, dynamic> map) {
    return WeatherData(
      cityName: map['cityName'] as String,
      country: map['country'] as String,
      latitude: map['latitude'] as double,
      longitude: map['longitude'] as double,
      population: map['population'] as int,
      sunrise: map['sunrise'] as int,
      sunset: map['sunset'] as int,
      timezone: map['timezone'] as int,
      temperature: map['temperature'] as double,
      feelsLike: map['feelsLike'] as double,
      humidity: map['humidity'] as int,
      pressure: map['pressure'] as int,
      visibility: map['visibility'] as int,
      windSpeed: map['windSpeed'] as double,
      clouds: map['clouds'] as int,
      weatherMain: map['weatherMain'] as String,
      weatherDescription: map['weatherDescription'] as String,
      additionalProperties: Map<String, dynamic>.from(
        (map['additionalProperties'] as Map<String, dynamic>),
      ),
    );
  }

  // String toJson() => json.encode(toMap());

  // Method to convert WeatherData instance to JSON
  Map<String, dynamic> toJson() {
    return {
      'city_name': cityName,
      'country': country,
      'latitude': latitude,
      'longitude': longitude,
      'population': population,
      'sunrise': sunrise,
      'sunset': sunset,
      'timezone': timezone,
      'temperature': temperature,
      'feels_like': feelsLike,
      'humidity': humidity,
      'pressure': pressure,
      'visibility': visibility,
      'wind_speed': windSpeed,
      'clouds': clouds,
      'weather_main': weatherMain,
      'weather_description': weatherDescription,
      'additional_properties': additionalProperties,
    };
  }

  factory WeatherData.fromJson(String source) => WeatherData.fromMap(json.decode(source) as Map<String, dynamic>);

  @override
  String toString() {
    return 'WeatherData(cityName: $cityName, country: $country, latitude: $latitude, longitude: $longitude, population: $population, sunrise: $sunrise, sunset: $sunset, timezone: $timezone, temperature: $temperature, feelsLike: $feelsLike, humidity: $humidity, pressure: $pressure, visibility: $visibility, windSpeed: $windSpeed, clouds: $clouds, weatherMain: $weatherMain, weatherDescription: $weatherDescription, additionalProperties: $additionalProperties)';
  }

  @override
  bool operator ==(covariant WeatherData other) {
    if (identical(this, other)) return true;
    final mapEquals = const DeepCollectionEquality().equals;

    return other.cityName == cityName &&
        other.country == country &&
        other.latitude == latitude &&
        other.longitude == longitude &&
        other.population == population &&
        other.sunrise == sunrise &&
        other.sunset == sunset &&
        other.timezone == timezone &&
        other.temperature == temperature &&
        other.feelsLike == feelsLike &&
        other.humidity == humidity &&
        other.pressure == pressure &&
        other.visibility == visibility &&
        other.windSpeed == windSpeed &&
        other.clouds == clouds &&
        other.weatherMain == weatherMain &&
        other.weatherDescription == weatherDescription &&
        mapEquals(other.additionalProperties, additionalProperties);
  }

  @override
  int get hashCode {
    return cityName.hashCode ^
        country.hashCode ^
        latitude.hashCode ^
        longitude.hashCode ^
        population.hashCode ^
        sunrise.hashCode ^
        sunset.hashCode ^
        timezone.hashCode ^
        temperature.hashCode ^
        feelsLike.hashCode ^
        humidity.hashCode ^
        pressure.hashCode ^
        visibility.hashCode ^
        windSpeed.hashCode ^
        clouds.hashCode ^
        weatherMain.hashCode ^
        weatherDescription.hashCode ^
        additionalProperties.hashCode;
  }
}



// // // // app.py
from flask import Flask, request, jsonify
from flask_cors import CORS
import pandas as pd
from io import StringIO
import logging
from train import Train
from waitress import serve # type: ignore
import numpy as np  # Add this import

app = Flask(__name__)
CORS(app)

# logging.basicConfig(level=logging.DEBUG)
api_key = "773211ac46a8a3e591f72ae278de8280"

@app.route('/upload', methods=['POST'])
def upload_and_predict():
    data = request.get_json()

    # Extract weather data and CSV data from request
    temperature = data['temperature']
    wind_speed = data['wind_speed']
    humidity = data['humidity']
    pressure = data['pressure']
    visibility = data['visibility']
    clouds = data['clouds']
    weather_main = data['weather_main']
    store_location = data['store_location']
    csv_data = data['csv_data']

    # Read CSV data
    csv_file = StringIO(csv_data)
    inventory_data = pd.read_csv(csv_file)

    weather_data = {
        'main': {'temp': temperature, 'feels_like': temperature, 'humidity': humidity, 'pressure': pressure},
        'visibility': visibility,
        'wind': {'speed': wind_speed},
        'clouds': {'all': clouds},
        'weather': [{'main': weather_main}]
    }

    try:
        train = Train()
        X_train, X_test, y_train, y_test, model = train.preprocess_and_train(inventory_data, weather_data)
        if X_train is not None:
            restock_suggestions = train.make_prediction(inventory_data, location=store_location)
            # Convert restock_suggestions to a JSON serializable format
            restock_suggestions = [{k: (int(v) if isinstance(v, (np.int64, np.int32)) else v) for k, v in suggestion.items()} for suggestion in restock_suggestions]
            return jsonify({'predicted_sales': restock_suggestions})
        else:
            return jsonify({'error': 'Training data is not sufficient.'}), 400
    except Exception as e:
        logging.error(f"Error during upload_and_predict: {str(e)}")
        return jsonify({'error': str(e)}), 500

# @app.route('/upload', methods=['POST'])
# def upload_and_predict():
#     data = request.get_json()

#     # Extract weather data and CSV data from request
#     temperature = data['temperature']
#     wind_speed = data['wind_speed']
#     humidity = data['humidity']
#     pressure = data['pressure']
#     visibility = data['visibility']
#     clouds = data['clouds']
#     weather_main = data['weather_main']
#     store_location = data['store_location']
#     csv_data = data['csv_data']

#     # Read CSV data
#     csv_file = StringIO(csv_data)
#     inventory_data = pd.read_csv(csv_file)

#     weather_data = {
#         'main': {'temp': temperature, 'feels_like': temperature, 'humidity': humidity, 'pressure': pressure},
#         'visibility': visibility,
#         'wind': {'speed': wind_speed},
#         'clouds': {'all': clouds},
#         'weather': [{'main': weather_main}]
#     }

#     try:
#         train = Train()
#         X_train, X_test, y_train, y_test, model = train.preprocess_and_train(inventory_data, weather_data)
#         if X_train is not None:
#             restock_suggestions = train.make_prediction(inventory_data, location=store_location)
#             # Convert restock_suggestions to a JSON serializable format
#             restock_suggestions = [{k: (int(v) if isinstance(v, (np.int64, np.int32)) else v) for k, v in suggestion.items()} for suggestion in restock_suggestions]
#             return jsonify({'predicted_sales': restock_suggestions})
#         else:
#             return jsonify({'error': 'Training data is not sufficient.'}), 400
#     except Exception as e:
#         logging.error(f"Error during upload_and_predict: {str(e)}")
#         return jsonify({'error': str(e)}), 500

@app.route('/weather', methods=['GET'])
def get_weather():
    location = request.args.get('location')
    if not location:
        return jsonify({'error': 'Location is required'}), 400
    
    weather_url = f'http://api.openweathermap.org/data/2.5/weather?q={location}&appid={api_key}&units=metric'
    
    response = request.get(weather_url)
    if response.status_code == 200:
        weather_data = response.json()
        return jsonify(weather_data), 200
    else:
        return jsonify({'error': 'Error fetching weather data'}), response.status_code

if __name__ == '__main__':
    app.run(debug=True)
    serve(app, host="0.0.0.0", port=5000)



// // // // train.py
import pandas as pd
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.utils import shuffle
import matplotlib
matplotlib.use('Agg')  # Use Agg backend for non-GUI environments
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score
import joblib
import requests

api_key = "773211ac46a8a3e591f72ae278de8280"


class Train:
    REORDER_LEVEL = 50
    MIN_REORDER_QUANTITY = 100

    def __init__(self):
        self.model = None

    # Step 2: Preparing the Data
    def preprocess_data(self, inventory_data, weather_data):
        weather_dict = {
            'temp': weather_data['main']['temp'],
            'feels_like': weather_data['main']['feels_like'],
            'humidity': weather_data['main']['humidity'],
            'pressure': weather_data['main']['pressure'],
            'visibility': weather_data['visibility'],
            'wind_speed': weather_data['wind']['speed'],
            'rain': weather_data.get('rain', {}).get('1h', 0),
            'clouds': weather_data['clouds']['all'],
            'weather': weather_data['weather'][0]['main']
        }

        weather_df = pd.DataFrame([weather_dict])
        df = pd.concat([inventory_data, weather_df], axis=1)
        df = shuffle(df)
        df.fillna(method='ffill', inplace=True)
        df.fillna(method='bfill', inplace=True)
        df.interpolate(method='linear', inplace=True)
        df.dropna(subset=['Sales'], inplace=True)
        df = df.convert_dtypes()
        numeric_df = df.select_dtypes(include=['number'])

        return numeric_df

    def visualize_data(self, df):
        sns.pairplot(df)
        plt.savefig('pairplot.png')  # Save plot as an image
        plt.close()
        plt.figure(figsize=(12, 8))
        sns.heatmap(df.corr(), annot=True, cmap='coolwarm')
        plt.savefig('heatmap.png')  # Save plot as an image
        plt.close()

    def choose_model(self):
        return RandomForestRegressor(n_estimators=100, random_state=42)

    def train_model(self, model, X_train, y_train):
        model.fit(X_train, y_train)
        self.model = model  # Store the model
        return model

    def evaluate_model(self, model, X_test, y_test):
        predictions = model.predict(X_test)
        mse = mean_squared_error(y_test, predictions)
        r2 = r2_score(y_test, predictions)
        return mse, r2, predictions

    def tune_model(self, model, X_train, y_train):
        parameters = {'n_estimators': [50, 100, 200], 'max_depth': [None, 10, 20, 30]}
        grid_search = GridSearchCV(model, parameters, cv=5)
        grid_search.fit(X_train, y_train)
        self.model = grid_search.best_estimator_  # Store the best estimator
        return grid_search.best_estimator_

    def preprocess_and_train(self, inventory_data, weather_data):
        preprocessed_data = self.preprocess_data(inventory_data, weather_data)
        self.visualize_data(preprocessed_data)

        if 'Sales' in preprocessed_data.columns:
            features = preprocessed_data[['temp', 'feels_like', 'humidity', 'pressure', 'visibility', 'wind_speed', 'rain', 'clouds']]
            target = preprocessed_data['Sales']

            X_train, X_test, y_train, y_test = train_test_split(features, target, test_size=0.2, random_state=42)
            model = self.choose_model()
            model = self.train_model(model, X_train, y_train)
            mse, r2, predictions = self.evaluate_model(model, X_test, y_test)
            print(f"Model Performance: MSE = {mse}, R2 = {r2}")
            model = self.tune_model(model, X_train, y_train)
            joblib.dump(model, 'sales_prediction_model.pkl')
            return X_train, X_test, y_train, y_test, model
        else:
            return None, None, None, None, None

    def get_weather_data(self, location):
        url = f"http://api.openweathermap.org/data/2.5/weather?q={location}&appid={api_key}&units=metric"
        response = requests.get(url)
        weather_data = response.json()
        return weather_data

    def make_prediction(self, inventory_data, location):
        # Load the model
        model = joblib.load('sales_prediction_model.pkl')

        # Get weather data
        weather_data = self.get_weather_data(location)

        # Extract relevant weather information
        weather_info = {
            'temp': weather_data['main']['temp'],
            'feels_like': weather_data['main']['feels_like'],
            'humidity': weather_data['main']['humidity'],
            'pressure': weather_data['main']['pressure'],
            'visibility': weather_data['visibility'],
            'wind_speed': weather_data['wind']['speed'],
            'rain': weather_data.get('rain', {}).get('1h', 0),
            'clouds': weather_data['clouds']['all'],
            'weather': weather_data['weather'][0]['main']
        }

        # Ensure that only numeric columns are used for prediction
        numeric_columns = ['temp', 'feels_like', 'humidity', 'pressure', 'visibility', 'wind_speed', 'rain', 'clouds']

        # Prepare data for prediction
        prediction_data = []
        for _, row in inventory_data.iterrows():
            item_data = [weather_info[col] for col in numeric_columns]
            prediction_data.append(item_data)

        prediction_data = pd.DataFrame(prediction_data, columns=numeric_columns)

        # Make predictions
        predictions = model.predict(prediction_data)

        # Generate restock suggestions
        restock_suggestions = []
        for i, pred in enumerate(predictions):
            # Use index as unique identifier
            item_id = int(i)  # Ensure the item_id is a standard Python int
            current_stock = int(inventory_data.iloc[i]['Quantity'])  # Ensure current_stock is a standard Python int
            predicted_demand = float(pred)  # Convert predicted demand to float

            restock_quantity = max(0, self.MIN_REORDER_QUANTITY - current_stock) if current_stock < self.REORDER_LEVEL else 0

            if restock_quantity > 0:
                restock_suggestions.append({
                    'item_id': item_id,
                    'current_stock': current_stock,
                    'predicted_demand': predicted_demand,
                    'restock_quantity': restock_quantity
                })

        return restock_suggestions

if __name__ == "__main__":
    print("This file is intended to be imported and used as a module.")

